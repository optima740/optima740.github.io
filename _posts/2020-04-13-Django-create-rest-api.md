---
layout: post
title: Django. Быстро прикручиваем REST API к проекту.
---
![](/image/post-2020-04-13/add_rest.JPG)

Давайте рассмотрим Django REST framework (`djangorestframework`), применительно к своему Django-проекту. Это библиотека, которая взаимодействует с моделями Django для реализации гибкого API в рамках разрабатываемого проекта.  
Итак, Django REST framework использует три слоя: маршрутизатор (`urls`), представление (`ViewSet`) и сериализатор (`serializer`).  
**Маршрутизатор** определяет URL-адреса, которые будут предоставлять доступ к каждому виду.    
**Представление** определяет функции или классы (чтение, создание, обновление, удаление), которые будут доступны через API.  
**Сериализатор** преобразует информацию, хранящуюся в базе данных, и определенную с помощью моделей Django, в формат, который легко и эффективно передается через API.  
  
Собственно, по этим слоям мы и будем двигаться при создании REST API в своем приложении.   
Не забываем добавить библиотеку `djangorestframework` в настройки нашего проекта. В файле `settings.py` добавим в атрибут установленных приложений `INSTALLED_APPS = […]` строку `rest_framework` в кавычках.  
Далее, создадим отдельную директорию `api/` в корне каталога с приложением на одном уровне с директориями `templates` и `static`. Внутри директории `api/` будут располагаться наши файлы (слои) `serializers.py`, `views.py` и `urls.py`.
Создадим для начала сериализатор (в `serializers.py`), наследуя его от `ModelSerializer`:
```python
class ThingSerializer(serializers.ModelSerializer):
  class Meta:
    model = Thing
    fields = ('name', )
```  
`model` - тут мы указываем какую модель будем использовать (импортируем из `models.py`)  
`fields` - указываем, какие поля доступны этому сериализатору из выбранной модели. Также, может быть установлен `exclude` вместо `fields`, который будет включать все поля модели, кроме тех, которые указаны в exclude.  

Сериализатор анализирует информацию в обоих направлениях (чтение и запись), тогда как представление (`ViewSet`)  - это тот код, в котором определены доступные операции. Наиболее распространенным ViewSet является `ModelViewSet`  
Внутри `views.py` создаем представление (класс) наследуя его от `ModelViewSet`:    
```python
class ThingViewSet(viewsets.ModelViewSet):
    queryset = Thing.objects.all()
    serializer_class = ThingSerializer
```  
`queryset` – список, срез объектов запрошенных из БД. `Thing.objects.all()`- в данном случае запрашиваем все доступные. Можем также использовать фильтрацию: `Thing.objects.filter(<название поля в models>=<значение>)`
`serializer_class` – привязываем наш сериализатор (импортируя его из `serializers.py`)  

Для корректной работы нашего представления, нам осталось пробросить к нему URL, чтобы запросы клиента попадали в наше представление (вьюху) через URL. Для этого, в основном файле проекта `urls.py` (находится на одном уровне с `settings.py`), делаем связность urls с urls из каталога `api\`, добавляя в список `urlpatterns[…]` :  
```python
urlpatterns = [
	path('api/', include('<директория с приложением>.api.urls')),
	
]
```  
Теперь, при обращении к адресу `..api/`, запрос пользователя будет перенаправлен в `api\urls.py` .
Ну и наконец, в каталоге `api\` в `urls.py` делаем привязку к нашему представлению, добавляя в список `urlpatterns[…]`:
```python
urlpatterns = [
	url(r'^thing/$', ThingViewSet.as_view(), name='ThingViewSet'),
```
В итоге, обратившись по адресу:` ../api/thing/`, мы получим список полей из нашей модели. Также мы можем получить данный список в JSON формате, сделав запрос вида: `../api/thing/?format=json`  

В данной статье рассмотрен самый простой способ "поднять" REST API в своем приложении с минимальным функционалом. Для полноценного взаимодействия, чтобы клиент мог делать изменения, обновлять и удалять данные, то есть операции Create, Read, Update, Delete (CRUD), необходимо переопределять родительские методы класса `ModelViewSet`, и добавлять соответствующий функционал в `ThingSerializer`. Но об этом в другой раз.















