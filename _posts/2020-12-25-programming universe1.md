---
layout: post
title: Вселенная программирования. Введение.
category: universe
---
![](/image/post-2020-12-25/1.png)
Данной своей статьей я хотел бы начать раскрывать серию тем связанных с глобальным (стратегическим) пониманием вселенной программирования. 

На сегодняшний день, конкуренция и требования в области программирования растут с каждым днем. Количество знаний необходимых технологий и фреймворков для того, чтобы ты мало-мальски подходил под критерии младшего помощника разработчика, только увеличивается. Это, своего рода, вечная гонка изученной информации и опыта длиною в жизнь. И я с этим не спорю и считаю, что так и должно быть в развитии каждого хорошего специалиста – не важно программист ты, врач или электрик.  
Тенденции современного рынка труда в сфере разработки, в большинстве своем, диктуют нам необходимость иметь узко направленные хорошие знания конкретного стека (а иногда даже и одного фреймворка). Да, знание определенного стека, состоящего из различных фреймворков и технологий, - это очень хорошо! Но, что насчет глобального взгляда на программистскую сферу с точки зрения информатики (computer science), возможно местами даже немного абстрактного?  

В одной из своих первых [статей](https://optima740.github.io/imperative/2020/02/17/go-to-stage-down/), мы уже отправлялись в «машинное отделение» и рассматривали в упрощенном виде, как происходят процессы выполнения кода на самом низшем – машинном уровне.  Сегодня (и в данной серии статей «Вселенная программирования») я предлагаю, наоборот, возвыситься и посмотреть свысока на всю систему понимания программирования глобально.  
Я имею ввиду понимание программирования, как целостной системы programming in small и programming in large через парадигмы и концепции программирования, применимые к разработке и проектированию программных систем. После не малого времени потраченного на изучение программирования, именно в академическом (классическом) стиле, у меня и появилась идея написать ряд статей, посвященных этому. Конечно же вся представленная информация, это некая упрощенная для понимания система, которую я смог выстроить определенным образом при изучении данной темы.  

Итак, глобально целостную систему понимания программирования можно разделить на два подхода в написании и проектировании кода (или две глобальные сферы, например, как микро и макро экономика, каждая из которых решает свой класс задач):

- **Programming in small.**
- **Programming in large.**  

**Programming in small** (программирование в малом) – это концепция, которая охватывает создание небольших программ или кодирование эффективных алгоритмов, удовлетворяющих определенной асимптотики сложности (исполнение за полиномиальное время - сложность их ниже, чем O(n^x)). В разработке задействован один программист или небольшая группа. Например, классические соревнования по олимпиадному программированию – это типичный programming in small.  

**Programming in large** (программирование больших проектов) – это подход к разработке и проектированию структур данных, сложных масштабируемых проектов с использованием абстракции и модульности, их дальнейшая поддержка и модернизация. Делается большой упор на планирование и создание качественной документации. Задействованы большие группы разработчиков, или целые отделы.  

Для того, чтобы разработать проект или реализовать какую-либо задачу в программировании, необходимо иметь понимание, какая парадигма программирования (а возможно и не одна) лучше всего подойдет под решение поставленной задачи.  

**Парадигма программирования** – подход к программированию, основанный на математической теории или на логически формализованном множестве принципов. Каждая **парадигма содержит набор концепций программирования**, которые подходят для решения определенного класса задач и проектов.  
В реальном мире на практике, самый популярный случай использования различных парадигм это 95% императивного программирования + ООП. Но встречаются и другие случаи, например, функциональное + ООП.  
Для построения сложной системы необходимо иметь в арсенале множество парадигм для хорошей ясной и продуктивной реализации всех ее подсистем. Вот наиболее популярные языки программирования представляющие различные парадигмы:  

- **Императивное + ООП** - Java, C++, C#, Python.
- **Дискретное синхронное программирование** - Esterel, Lustre, Argos, Signal.
- **Логическое программирование** - Prolog, Planner.
- **Функциональное программирование** - Haskell, F#, LISP.

Также существуют языки, которые поддерживают в себе сразу несколько парадигм, например, языки Oz, Julia, Kotlin, а также всеми любимый C++. 
Но даже если выбранный язык не поддерживает ту или иную парадигму, ее можно попытаться сэмулировать. Например, на языке C можно программировать в ООП-стиле.  

И еще хотел добавить два довольно абстрактных, но, на мой взгляд, крайне важных определения, которые нам помогут в дальнейшем:  

**Детерминизм** – предсказуемость системы. Четкая последовательность действий, ведущих к ожидаемому результату. Нет свободы, нет хаоса в системе. Например, работа механических часов.   
**Недетерминизм** – непредсказуемость системы. Хаотичность, полная свобода в поведении системы. Результат непредсказуем. Например, хаотичное движение молекул газа.  

Нахождение правильного баланса между этими состояниями является одной из ключевых задач при разработке крупных проектов и систем.  

Таким образом, становится очевидным тот момент, что прежде чем затачиваться под определенный язык программирования (не говоря уже о конкретном фреймворке), необходимо, хотя бы образно, представлять ту глобальную систему концепций из computer science, согласно которой и исходя из круга поставленных задач, мы уже и приходим к выбору использования того или иного стека технологий в рамках работы над конкретным проектом.  
Приведу следующую аналогию. На мой взгляд, если ты хочешь стать, например, хорошим автомехаником-мотористом, то несовсем правильно начинать учиться с того, как быстро и качественно крутить гайки, на глаз определять диаметр резьб, и учиться делать это только с определенной маркой автомобилей, приэтом, совершенно не понимая и не зная тенденций мирового автопрома, теории и развития ДВС и других сопутствующих знаний, например, электронной диагностики.  Но, вот если, ты представляешь, как устроен мировой автопром, хорошо знаком с теорией строения ДВС, понимаешь, как работает электронная система управления двигателем, то научиться откручивать и закручивать гайки в правильном порядке на конкретном моторе, зная за что отвечает и как устроена каждая его подсистема, думаю, не составит труда. Да, с точки зрения тактики бизнеса по авто-ремонту и быстрого зарабатывания денег, вполне подойдет (и даже будет предпочтительнее) первый вариант. Но, если развиваться как хороший специалист стратегически, всегда иметь спрос на свои услуги и быть всегда востребованным, то необходимо развивать репутацию грамотного квалифицированного спеца, который понимает свое дело, в первую очередь, глобально.













 






