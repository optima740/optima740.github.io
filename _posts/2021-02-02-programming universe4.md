---
layout: post
title: Вселенная программирования. Ключевые концепции ч1.
category: universe
---
![](/image/post-2021-01-10/1.png)  

Продолжая серию тем о вселенной программирования, в данной статье я хотел бы поделиться своими мыслями после изученной информации, об основных (ключевых) концепциях в программировании. Ранее я уже говорил о глобальных вещах в программистской вселенной, таких как: 

- [Статья 1](https://optima740.github.io/2020/12/25/programming-universe1/). Макро и микро подход к задачам программирования, понятия детерминизма и парадигм программирования.  
- [Статья 2](https://optima740.github.io/2021/01/10/programming-universe2/). Подход к проектированию программных систем, исходя из глобального взгляда через призму парадигм. Необходимость выделения главных задач, для решения которых подбирается применение наиболее подходящих парадигм программирования способных эти задачи решить и, соответственно, получения набора конкретных языков и фреймворков.  
- [Статья 3](https://optima740.github.io/2021/01/26/programming-universe3/). Основные вычислительные модели и их главные характеристики, на которых основываются парадигмы программирования и конкретные языки, представляющие данные парадигмы.  

В сегодняшней статье мы опускаемся на слой ниже, и поговорим уже о конкретных концепциях в программировании, а точнее, главных (ключевых) идеях, на которых и держится искусство программирования, как понятность, корректность и прозрачность кода.  

Итак, ключевые концепции программирования комбинации которых и входят в состав различных парадигм:  

- **Именованные состояния.**  

- **Замыкания.**  

- **Параллелизм.**  

- **Абстракция данных.**  

**Именованное состояние** – данное состояние вводит понятие абстрактного времени в парадигму. Это объекты, к которым можно обращаться по имени (имеют связь между именем объекта и адресом в памяти), способные менять свое состояние (значение) во время исполнения программы.  
Конечно же, ярким примером данной концепции является **переменная** в императивной парадигме. *Переменная* характеризуется последовательностью принимаемых значений в процессе работы кода, и своим уникальным именем. Противоположное именованному состоянию по семантике понятие – не именованное состояние (монады).  
На примере изучаемого мной Питона (императивная парадигма) и его ссылочной модели данных, под капотом переменной мы имеем имя ссылки, которая уникальна для своей области видимости в пространстве имен. Ссылка указывает на область в динамической памяти, где хранится непосредственно сам объект, к которому мы можем обратиться по имени ссылки. 

![](/image/post-2021-02-02/Pic1.jpg)

Для именованного состояния характерен недетерминизм, потому что изменение значений в процессе времени уже подразумевает некую степень хаотичности системы и непредсказуемость ее поведения.
Именно поэтому для детерминированного характера функциональной парадигмы, определения именованного состояния не существует, т.к. в данной парадигме нет понятия времени. Есть лишь функции (как в математике), которые возвращают один и тот же результат без побочных эффектов. Но для систем, описывающих поведение реального мира, в котором многие вещи подвержены изменениям с течением времени, без именованных состояний не обойтись. Более того, в реальном мире одни и те же объекты при одинаковых воздействиях, могут выдавать различные результаты. Это называется побочными эффектами, характерными для недетерминированной системы.  

Именованные состояния полезны и при организации модульности. Модульность системы говорит о том, что в случае необходимости изменения системы, мы имеем возможность модифицировать отдельную ее часть (модуль) без модификации системы целиком. Организовывая программу в виде модулей с применением концепции именованных состояний, мы имеем плюс в плане удобства и выразительности. Однако главный недостаток этого подхода в том, что система сразу становится непредсказуемой (функциональные блоки системы имеют побочные эффекты при работе программы), и обычно код таких систем начинает запутываться и усложняться.  

Таком образом получается, (как я уже говорил в предыдущей статье) что парадигма с поддержкой именованного состояния является более выразительной для описания процессов реального мира, но в тоже время и более непредсказуемой (носит недетерминированный характер, не всегда корректна).  
Возможен некий компромиссный подход к использованию именованных состояний - инкапсулировать именованные состояния в системе в виде классов как абстрактных типов данных. В таком случае каждый АТД задаёт конкретную структуру данных с формальным набором операций над ней, корректность которого доказывать уже проще.  
Но об абстракции данных мы поговорим отдельно в следующих статьях.  

Кроме того, в данную концепцию можно добавить такое понятие как **именованные записи** (**record**). Сюда мы можем отнести структуры данных (массивы, списки, деревья, хэш-таблицы и тд), в общем это все сущности, имеющие набор ссылок на условные элементы с индексированным доступом к каждому элементу. Класс без методов, в котором есть только общедоступные поля, к которым имеется доступ по имени, также является именованной записью. 













