I"s1<p><img src="/image/post-2020-12-25/1.png" alt="" />
Данной своей статьей я хотел бы начать раскрывать серию тем связанных с глобальным (стратегическим) пониманием вселенной программирования.</p>

<p>На сегодняшний день, конкуренция и требования в области программирования растут с каждым днем. Количество знаний необходимых технологий и фреймворков для того, чтобы ты мало-мальски подходил под критерии младшего помощника разработчика, только увеличивается. Это, своего рода, вечная гонка изученной информации и опыта длиною в жизнь. И я с этим не спорю и считаю, что так и должно быть в развитии каждого хорошего специалиста – не важно программист ты, врач или электрик.<br />
Тенденции современного рынка труда в сфере разработки, в большинстве своем, диктуют нам необходимость иметь узко направленные хорошие знания конкретного стека (а иногда даже и одного фреймворка). Да, знание определенного стека, состоящего из различных фреймворков и технологий, - это очень хорошо! Но, что насчет глобального взгляда на программистскую сферу с точки зрения информатики (computer science), возможно местами даже немного абстрактного?</p>

<p>В одной из своих первых <a href="https://optima740.github.io/imperative/2020/02/17/go-to-stage-down/">статей</a>, мы уже отправлялись в «машинное отделение» и рассматривали в упрощенном виде, как происходят процессы выполнения кода на самом низшем – машинном уровне.  Сегодня (и в данной серии статей «Вселенная программирования») я предлагаю, наоборот, возвыситься и посмотреть свысока на всю систему понимания программирования глобально.<br />
Я имею ввиду понимание программирования, как целостной системы programming in small и programming in large через парадигмы и концепции программирования, применимые к разработке и проектированию программных систем. После не малого времени потраченного на изучение программирования, именно в академическом (классическом) стиле, у меня и появилась идея написать ряд статей, посвященных этому. Конечно же вся представленная информация, это некая упрощенная для понимания система, которую я смог выстроить определенным образом при изучении данной темы.</p>

<p>Итак, глобально целостную систему понимания программирования можно разделить на два подхода в написании и проектировании кода (или две глобальные сферы, например, как микро и макро экономика, каждая из которых решает свой класс задач):</p>

<ul>
  <li><strong>Programming in small.</strong></li>
  <li><strong>Programming in large.</strong></li>
</ul>

<p><strong>Programming in small</strong> (программирование в малом) – это концепция, которая охватывает создание небольших программ или кодирование эффективных алгоритмов, удовлетворяющих определенной асимптотики сложности (исполнение за полиномиальное время - сложность их ниже, чем O(n^x)). В разработке задействован один программист или небольшая группа. Например, классические соревнования по олимпиадному программированию – это типичный programming in small.</p>

<p><strong>Programming in large</strong> (программирование больших проектов) – это подход к разработке и проектированию структур данных, сложных масштабируемых проектов с использованием абстракции и модульности, их дальнейшая поддержка и модернизация. Делается большой упор на планирование и создание качественной документации. Задействованы большие группы разработчиков, или целые отделы.</p>

<p>Для того, чтобы разработать проект или реализовать какую-либо задачу в программировании, необходимо иметь понимание, какая парадигма программирования (а возможно и не одна) лучше всего подойдет под решение поставленной задачи.</p>

<p><strong>Парадигма программирования</strong> – подход к программированию, основанный на математической теории или на логически формализованном множестве принципов. Каждая <strong>парадигма содержит набор концепций программирования</strong>, которые подходят для решения определенного класса задач и проектов.<br />
В реальном мире на практике, самый популярный случай использования различных парадигм это 95% императивного программирования + ООП. Но встречаются и другие случаи, например, функциональное + ООП.<br />
Для построения сложной системы необходимо иметь в арсенале множество парадигм для хорошей ясной и продуктивной реализации всех ее подсистем. Вот наиболее популярные языки программирования представляющие различные парадигмы:</p>

<ul>
  <li><strong>Императивное + ООП</strong> - Java, C++, C#, Python.</li>
  <li><strong>Дискретное синхронное программирование</strong> - Esterel, Lustre, Argos, Signal.</li>
  <li><strong>Логическое программирование</strong> - Prolog, Planner.</li>
  <li><strong>Функциональное программирование</strong> - Haskell, F#, LISP.</li>
</ul>

<p>Также существуют языки, которые поддерживают в себе сразу несколько парадигм, например, языки Oz, Julia, Kotlin, а также всеми любимый C++. 
Но даже если выбранный язык не поддерживает ту или иную парадигму, ее можно попытаться сэмулировать. Например, на языке C можно программировать в ООП-стиле.</p>

<p>И еще хотел добавить два довольно абстрактных, но, на мой взгляд, крайне важных определения, которые нам помогут в дальнейшем:</p>

<p><strong>Детерминизм</strong> – предсказуемость системы. Четкая последовательность действий, ведущих к ожидаемому результату. Нет свободы, нет хаоса в системе. Например, работа механических часов. <br />
<strong>Недетерминизм</strong> – непредсказуемость системы. Хаотичность, полная свобода в поведении системы. Результат непредсказуем. Например, хаотичное движение молекул газа.</p>

<p>Нахождение правильного баланса между этими состояниями является одной из ключевых задач при разработке крупных проектов и систем.</p>

<p>Таким образом, становится очевидным тот момент, что прежде чем затачиваться под определенный язык программирования (не говоря уже о конкретном фреймворке), необходимо, хотя бы образно, представлять ту глобальную систему концепций из computer science, согласно которой и исходя из круга поставленных задач, мы уже и приходим к выбору использования того или иного стека технологий в рамках работы над конкретным проектом.<br />
Приведу следующую аналогию. На мой взгляд, если ты хочешь стать, например, хорошим автомехаником-мотористом, то несовсем правильно начинать учиться с того, как быстро и качественно крутить гайки, на глаз определять диаметр резьб, и учиться делать это только с определенной маркой автомобилей, приэтом, совершенно не понимая и не зная тенденций мирового автопрома, теории и развития ДВС и других сопутствующих знаний, например, электронной диагностики.  Но, вот если, ты представляешь, как устроен мировой автопром, хорошо знаком с теорией строения ДВС, понимаешь, как работает электронная система управления двигателем, то научиться откручивать и закручивать гайки в правильном порядке на конкретном моторе, зная за что отвечает и как устроена каждая его подсистема, думаю, не составит труда. Да, с точки зрения тактики бизнеса по авто-ремонту и быстрого зарабатывания денег, вполне подойдет (и даже будет предпочтительнее) первый вариант. Но, если развиваться как хороший специалист стратегически, всегда иметь спрос на свои услуги и быть всегда востребованным, то необходимо развивать репутацию грамотного квалифицированного спеца, который понимает свое дело, в первую очередь, глобально.</p>

:ET