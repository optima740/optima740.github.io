I"+<p><img src="/image/post-2021-01-10/1.png" alt="" /></p>

<p>В предыдущих моих постах из данной серии (<a href="https://optima740.github.io/universe/2020/12/25/programming-universe1/">раз</a> и <a href="https://optima740.github.io/universe/2021/01/10/programming-universe2/">два</a>), я писал о том, что глобально вселенную программирования можно разделить на микро и макро подмножества – <strong>programming in small</strong> и <strong>programming in large</strong> (ну как с экономикой). Следовательно, и круг решаемых задач разный. И вот, для того, чтобы правильно проектировать программные системы, необходимо четко выделять задачи, которые необходимо решить при помощи тех или иных наборов концепций программирования - <strong>парадигм программирования</strong>, которые уже и представляют нам конкретные языки программирования и фреймворки.</p>

<p>В данной статье я и хотел бы затронуть тему <em>вычислительных моделей</em>, которые служат основой для различных парадигм программирования. Затронуть абстрактно, исходя из той информации, которую мне удалось изучить в этом направлении.</p>

<p>Итак, <strong>вычислительная модель</strong> (применительно к информатике) – это набор доказанной математической теории, некий опорный вычислительный аппарат, на котором основываются те концепции, которые объединяет парадигма программирования. Например, лямбда-исчисления Алонзо Черча является математическим аппаратом - фундаментом для парадигмы функционального программирования.</p>

<p>Для любой парадигмы можно выделить две важнейшие ключевые характеристики:</p>

<ul>
  <li><strong>Степень недетерминизма</strong> (насколько он явный).</li>
  <li><strong>Способность хранить значения</strong> (именованное состояние).</li>
</ul>

<p><strong>Недетерминизм считается явным или наблюдаемым</strong>, если мы явно видим различные результаты выполнения программы, которая имеет каждый раз одни и те же внутренние параметры при запуске. Такой характер поведения присущ, в первую очередь, для параллельного программирования (параллелизма) со свойственной ему проблемой конкуренции потоков (<em>race condition</em>): когда несколько частей кода могут выполняться одновременно, и нельзя по исходному тексту программы однозначно сказать, каким будет итог их работы. Потому что несколько потоков пытаются одновременно изменить состояние некоторого общего объекта, и результат зависит от промежутков времени между работой разных частей кода. Какой поток отработает последним, тот и зафиксирует итоговое состояние общего объекта. Но не всегда данный характер является крайне нежелательным, например, при моделировании систем реального мира, как раз требуется подобная парадигма с присущим явным недетерминизмом.</p>

<p><strong>Способность хранить значения</strong> (именованное состояние) – это возможность сохранять последовательность значений на протяжении хода выполнения программы. В императивной парадигме это переменные. В данной характеристике важна степень выраженности именованного состояния (<strong>stateless</strong> - <strong>stateful</strong>).</p>

<p>Итак, если попытаться представить основные направления вычислительных моделей, и, как следствие, парадигм программирования, то мы получим некое дерево.</p>

<p><img src="/image/post-2021-01-26/pic1.jpg" alt="" /></p>

<p>Ядро всей программистской концепции, некие глубинные принципы всего – это <strong>декларативная вычислительная модель</strong> (декларативное программирование).  Если очень поверхностно описать суть, то это <em>stateless</em>-программирование, где не используются переменные для хранения промежуточных состояний программы, которые могут меняться с течением времени исполнения кода и, соответственно, степень именованного состояния наименее выражена. Явный представитель декларативной модели – парадигмы <em>функционального</em> и <em>логического программирования</em>. Я уже писал пару постов на тему функционального программирования более подробно (<a href="https://optima740.github.io/universe/2020/07/04/Functional-programming/">раз</a> и <a href="https://optima740.github.io/universe/2020/07/28/FP-base-structs/">два</a>). В концепции функционального программирования мы последовательно вызываем чистые функции, подавая им на вход неизменяемые значения. Данная модель имеет явный детерминистический характер, и может быть использована для создания распределенных безопасных программных систем устойчивых к сбоям. Кроме того, данной модели свойственна <em>параллельность</em> (использование многопоточности – об этом отдельно поговорим позже). А значит это явная возможность эффективно использовать многоядерность современных процессоров, не упираясь в проблемы конкуренции параллельных потоков (<em>race condition</em>).<br />
От данной вычислительной модели, как от корня вниз уже могут исходить ветви направлений.<br />
Например, <strong>недетерминированная последовательная модель</strong> с более выраженной степенью именованного состояния (<em>stateful</em>), без параллелизма. Добавление именованного состояния даёт нам классическое императивное программирование: функции и переменные.<br />
Другая ветвь - <strong>параллельная детерминированная модель</strong>, с неименованными состояниями (<em>stateless</em>), где добавление параллельности приводит к парадигме параллельного логического программирования.</p>

<p>Данная схема всего лишь абстрактное представление основных направлений, в терминах которых и описаны те или иные парадигмы, представителями которых являются уже конкретные языки программирования, как имплементации определенных наборов концепций.</p>

<p>Что же в итоге нам все это дает в реальности? А то, что искусство проектирования программных систем – это умение выбирать парадигму с оптимальным множеством концепций, точнее всего подходящим конкретному проекту. Если концепций, которые помогут достичь цели проекта, будет слишком мало, то усложнится реализация системы – мы приходим к задачам <em>programming in small</em>. Если таких концепций будет слишком много, то сложным станет её проектирование, -это уже круг задач <em>programming in large</em>.<br />
Недетерминизм важен во всех программных системах, где взаимодействие происходит в реальном времени (например, клиент-серверные системы).<br />
Именованные состояния важны для обеспечения модульности проекта.<br />
<strong>Явный недетерминизм</strong> и <strong>именованные состояния</strong> - две крайние ситуации, между которыми важно уметь находить баланс при проектировании.</p>

:ET