<!doctype html>
<html lang="en">
 
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
  <title>
    
      Вселенная программирования. ООП. &middot; AndreyMelnikov.MyBlog
    
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-precomposed.ico" type="image/vnd.microsoft.icon">
  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico?">
  <link rel="alternate" type="application/atom+xml" title="AndreyMelnikov.MyBlog" href="/atom.xml">


  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Вселенная программирования. ООП." />
<meta name="author" content="Andrey Melnikov" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/universe/2021/05/19/programming-universe9/" />
<meta property="og:url" content="http://localhost:4000/universe/2021/05/19/programming-universe9/" />
<meta property="og:site_name" content="AndreyMelnikov.MyBlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-19T00:00:00+03:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Andrey Melnikov"},"headline":"Вселенная программирования. ООП.","dateModified":"2021-05-19T00:00:00+03:00","datePublished":"2021-05-19T00:00:00+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/universe/2021/05/19/programming-universe9/"},"@type":"BlogPosting","url":"http://localhost:4000/universe/2021/05/19/programming-universe9/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body>

  
	<table>
	<p></p>
	</table>
    <div class="container content">
	
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">AndreyMelnikov.MyBlog</a>
          <small>   # мой блог: IT-марафон.</small>
        </h3>
		<p><img src="/image/my_avatar.jpeg"</p>
      </header>

      <main>
        <a class="btn btn-outline-secondary" href="/history_posts" role="button">
    <font style="color: black; font-size: 24px; font-family: Arial">Все мои посты</font>
</a>

<article class="post">
  <h1 class="post-title">Вселенная программирования. ООП.</h1>
  <time datetime="2021-05-19T00:00:00+03:00" class="post-date">19 May 2021</time>
  <p><img src="/image/post-2021-01-10/1.png" alt="" /></p>

<p>Продолжаю развивать тему <a href="https://optima740.github.io/universe/2020/12/25/programming-universe1/">«Вселенная программирования»</a>. В данной статье я хотел бы немного затронуть парадигму ООП (ну или концепцию, я больше склоняюсь к тому, что ООП это концепция в рамках императивной парадигмы, нежели отдельная парадигма). Ну или точнее, показать, что абстракция данных, рассматриваемая в предыдущих статьях, применительно к сущности «объект», получила свое воплощение в отдельной концепции – ООП.</p>

<p>На сегодняшний день, наверное, только ленивый не слышал об <strong>объектно-ориентированном программировании</strong> (ООП). Эту тему очень любят спрашивать на собеседованиях. Я сам буквально недавно сталкивался с этим. Причем мой ответ не очень удовлетворил интервьюверов. Да и сам я понимал, что мои объяснения принципов ООП «своими словами» звучали немного размыто. Так что, давайте разбираться во всем в данной статье из «Вселенной».</p>

<p>ООП, как методология, появилась еще в 60х годах, тогда в Массачусетском технологическом университете Алан Кэй, и чуть позднее Иван Сазерленд определяет понятия «объект» и «экземпляр» и связывает их с концепцией классов. Однако, в доминирующую методологию ООП войдет гораздо позднее, примерно в начале 90х.</p>

<p>Сама идеология ООП создавалась как связь поведения сущности (объекта) с её данными в рамках идеи спроецировать объекты реального мира в программный код. В итоге мы имеем высокоуровневую абстракцию, которая облегчает взаимодействие для разработчиков, т. к. людям свойственно воспринимать окружающий мир, как множество взаимодействующих между собой объектов, поддающихся определенной классификации. 
Идею ООП описывают ее важнейшие принципы. Да-да, те самые всем до боли известные:</p>

<ul>
  <li>Полиморфизм.</li>
  <li>Наследование.</li>
  <li>Инкапсуляция.</li>
</ul>

<p>Те самые принципы, о которых так любят все спрашивать, и ждут совершенно типовых ответов. Но давайте посмотрим на них с точки зрения абстракций, о которых мы говорили ранее во «Вселенной программирования».</p>

<p><strong>Полиморфизм.</strong></p>

<p>Важнейший принцип ООП. Сущность можно назвать полиморфной, если она может работать с аргументами различных типов.<br />
В более техническом смысле, <strong>полиморфизм</strong> - это автоматический вызов корректного метода соответствующего класса-потомка, полностью совпадающего по сигнатуре с родительским методом предка (механизм переопределения методов). То есть <strong>выбор подходящего метода в момент его вызова будет выполнен автоматически в зависимости от типов конкретных аргументов</strong>.<br />
Если говорить о семантике полиморфизма, то полиморфизм – это способность системы использовать объекты с одинаковым интерфейсом (сигнатурой) без учета информации о внутренней реализации этих объектов.</p>

<p>Давайте рассмотрим следующий пример:<br />
Водитель приехал в сервис с задачей починить свой автомобиль. Так вот, автомобиль будет отремонтирован автосервисом в любом случае, но с учетом специализации мастера-ремонтника.<br />
В данном случае задача «починить» - полиморфна. Она может быть поставлена любому типу мастера-ремонтника, потому что все ремонтники умеют ремонтировать автомобиль, но каждый делает это с учетом своей специализации.<br />
Для ясности, я приведу пример, используя псевдокод.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ВодительАлекс = Водитель(…) – наследник класса Водитель.
МастерРемонтаДжон = Моторист(…) – Наследник класса РемонтникАвтомобилей.
ВодительАлекс.ПочинитьАвтомобиль(МастерРемонтаДжон)  

</code></pre></div></div>
<p>В данном примере в метод <code class="highlighter-rouge">ПочинитьАвтомобиль()</code> класса <code class="highlighter-rouge">Водитель</code> в качестве аргументов можно передавать не просто наследников класса <code class="highlighter-rouge">РемонтникАвтомобилей</code> но и другие классы, например, <code class="highlighter-rouge">ЗаправщикКондиционера</code>, которые поддерживают (реализуют) интерфейс (соответствует сигнатуре), требуемый методом <code class="highlighter-rouge">ПочинитьАвтомобиль()</code>.</p>

<p>Ну или более простой пример, так сказать, более примитивное ООП.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Автомобиль() – родительский класс (АТД)  

ЛегковойАвтомобиль(Автомобиль) – Наследник класса Автомобиль,  
реализующий его абстрактные методы.  

ФордФокус = ЛегковойАвтомобиль() – Экземпляр класса ЛегковойАвтомобиль.  

ФордФокус.ЗапускДвигателя() – будет вызван конкретный метод  
ЗапускДвигателя() класса ЛегковойАвтомобиль. При этом  
родительский АТД Автомобиль обязательно содержит свой  
собственный абстрактный метод ЗапускДвигателя().   
</code></pre></div></div>

<p><strong>Наследование.</strong></p>

<p>Избыточность кода является большой проблемой при разработке программных систем. Повторяющийся код служит источником ошибок, потому что, если баг был обнаружен и пофиксен в одном месте, то вполне вероятно, что могли упустить все повторяющиеся участки данного кода. Тоже само касается и внесения изменений в код. Каждый раз необходимо искать все повторяющиеся фрагменты.</p>

<p><strong>Наследование</strong> можно охарактеризовать как определение (создание) абстракций с выделением их общих взаимосвязей, но без повторений общих частей кода.<br />
Другими словами, <strong>наследование</strong> – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.<br />
Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом (хотя правильнее всего будет называть его подтипом - <em>subtype</em>).<br />
Необходимо отметить, что класс-потомок полностью удовлетворяет спецификации родительского класса, однако может иметь дополнительную функциональность (расширяет родительскую функциональность). Если мы говорим о построении более-менее сложной иерархии наследования, используя абстракцию данных, то с точки зрения интерфейсов (или АТД), каждый класс-наследник полностью реализует интерфейс (абстракцию) родительского класса. И из этого мы плавно переходим к методу подстановки.</p>

<p>В серьезном взрослом программировании наследование должно отвечать принципу подстановки Барбары Лисков (Буква <strong>L</strong> из правил <strong>SOLID</strong>):</p>

<p>Допустим у нас есть небольшая иерархия наследования:<br />
Родительский класс <code class="highlighter-rouge">Parrent</code>, и его класс-потомок (подтип) <code class="highlighter-rouge">Child</code>. (<code class="highlighter-rouge">Parrent --&gt; Child</code>).</p>

<p>Также у нас есть функция, однозначно корректно работающая с входным параметром <code class="highlighter-rouge">arg</code>:<br />
<code class="highlighter-rouge">function(arg)</code>, где <code class="highlighter-rouge">arg</code> – это объект типа <code class="highlighter-rouge">Parrent</code>.</p>

<p>Так вот метод подстановки Барбары Лисков (<strong>Liskov substitution principle, LSP</strong>) заключается в том, что если мы подставим в нашу <code class="highlighter-rouge">function(arg)</code>, аргумет <code class="highlighter-rouge">arg</code> типа <code class="highlighter-rouge">Child</code> (подтип <code class="highlighter-rouge">Parrent</code>), то функция должна также корректно работать, как и работала с аргументом родительского типа.<br />
Это говорит о том, что подклассы (или классы наследники), должны поддерживать родительский функционал и не должны менять родительские интерфейсы.</p>

<p>Наследование, как концепция относится к понятию «<strong>is-a</strong>» то есть класс «является» подклассом другого класса, в отличие от другой концепции <strong>композиции</strong>, которая относится к понятию «<strong>has-a</strong>», что означает данный класс «содержит» в себе (или ссылается на) экземпляр другого класса. 
При сложном проектировании программных систем, использование наследования лучше избегать, и если уж избежать этого не получается, то наследование должно соответствовать LSP (принципу подстановки описанному выше). Во всех остальных случаях, лучше использовать композицию.</p>

<p>Но это тема уже для отдельного разговора.</p>

<p><strong>Инкапсуляция.</strong></p>

<p>Если прямо и дословно, то инкапсуляция - это сокрытие реализации внутри сущности, концепция черного ящика. Но именно такой ответ, не всегда устраивает, например, интервьюверов на собеседовании :)<br />
Если более детально разобрать этот принцип, то можно сказать, что <strong>инкапсуляция</strong> - это такое свойство системы, позволяющее объединить данные и допустимые методы работы с этими данными внутри сущности (класса или объекта).<br />
Получается, что инкапсуляция — это не просто сокрытие. А вот сокрытие - это следствие инкапсуляции (обертывании) данных и методов внутри класса. И, соответственно, из этого и вытекает механизм модификации доступа (<em>Public, Protected, Private</em>), при помощи которого разработчик может определять различные градации доступа к внутренней реализации своего класса. Напомню:</p>

<ul>
  <li>
    <p><em>Public</em> – доступ к данным полностью разрешен из вне.</p>
  </li>
  <li>
    <p><em>Protected</em> - доступ к данным возможен только внутри своего класса или из классов-предков, которые состоят в иерархии наследования к данному классу.</p>
  </li>
  <li>
    <p><em>Private</em> – доступ к данным возможет только внутри своего класса.</p>
  </li>
</ul>

<p>На этом по ООП я пожалуй закончу. Конечно ООП является огромной темой для отдельного изучения и правильного понимания, и безусловно данная концепция (парадигма) стала одной из важнейших и опорных тем в мире программирования.</p>


</article>


<a href="/history_posts"><font style="color: gray; font-size: 22px; font-family: Arial">Назад к списку постов</font></a>
<p></p>
<p></p>
<p></p>

      </main>
	  
	
  

      <footer class="footer">
        <small><font style="color: gray; font-size: 16px; font-family: Arial">
		  <p><a href = 'https://vk.com/amelnikofcode'><font style="color: gray; font-size: 16px; font-family: Arial"> Мой профиль в ВК </font></a></p>
		  <p><a href = 'https://github.com/optima740'><font style="color: gray; font-size: 16px; font-family: Arial"> Мой профиль на GitHub</font></a></p>
		  &copy; <time datetime="2021-06-21T10:44:10+03:00">2021</time>
		</font>  
		  
        </small>
      </footer>
    </div>

    
  </body>
</html>
