<!doctype html>
<html lang="en">
 
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <title>
    
      Вселенная программирования. Глобальный взгляд на проектирование. &middot; AndreyMelnikov.MyBlog
    
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-precomposed.ico" type="image/vnd.microsoft.icon">
  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico?">
  <link rel="alternate" type="application/atom+xml" title="AndreyMelnikov.MyBlog" href="/atom.xml">


  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Вселенная программирования. Глобальный взгляд на проектирование." />
<meta name="author" content="Andrey Melnikov" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/universe/2021/01/10/programming-universe2/" />
<meta property="og:url" content="http://localhost:4000/universe/2021/01/10/programming-universe2/" />
<meta property="og:site_name" content="AndreyMelnikov.MyBlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-01-10T00:00:00+04:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Andrey Melnikov"},"headline":"Вселенная программирования. Глобальный взгляд на проектирование.","dateModified":"2021-01-10T00:00:00+04:00","datePublished":"2021-01-10T00:00:00+04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/universe/2021/01/10/programming-universe2/"},"@type":"BlogPosting","url":"http://localhost:4000/universe/2021/01/10/programming-universe2/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body>

  
	<table>
	<p></p>
	</table>
    <div class="container content">
	
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">AndreyMelnikov.MyBlog</a>
          <small>   # мой блог: IT-марафон.</small>
        </h3>
		<p><img src="/image/my_avatar.jpeg"</p>
      </header>

      <main>
        <a class="btn btn-outline-secondary" href="/history_posts" role="button">
    <font style="color: black; font-size: 24px; font-family: Arial">Все мои посты</font>
</a>

<article class="post">
  <h1 class="post-title">Вселенная программирования. Глобальный взгляд на проектирование.</h1>
  <time datetime="2021-01-10T00:00:00+04:00" class="post-date">10 Jan 2021</time>
  <p><img src="/image/post-2021-01-10/1.png" alt="" /></p>

<p>Любая программная система характеризуется двумя ключевыми характеристиками:</p>

<ul>
  <li><strong>Сложность.</strong></li>
  <li><strong>Хаотичность.</strong></li>
</ul>

<p><em>Сложность</em> определяется количеством базовых сущностей и связей между ними в системе (например, классы в проекте). Соответственно, чем их меньше, тем проще проект.</p>

<p><em>Хаотичность</em> говорит нам о том, насколько не детерминирована (вспоминаем <a href="http://127.0.0.1:4000/universe/2020/12/25/programming-universe1/">первую статью</a> данного цикла :) система в целом. Насколько она непредсказуема, если говорить иначе.</p>

<p>Каждый язык программирования создавался для решения определенной сферы задач. Но для любого множества задач можно найти такую парадигму программирования, в которой эти задачи будут решаться продуктивнее и эффективнее. Однако, стоит помнить, что не существует универсальной парадигмы для решения всех классов задач.<br />
При проектировании программной системы, выбор парадигмы является выбором той математической системы или системы логических принципов, содержащей концепции программирования, которые более точно охватили бы тот круг задач, который необходимо решить. В крупных проектах возможны применения нескольких парадигм, каждая из которых решала бы поставленные задачи на своем уровне (слое).<br />
Например, <strong>объектно-ориентированное программирование</strong> лучше всего подходит для создания систем, где подразумевается большое число взаимосвязанных абстракций данных, организованных в иерархии. <br />
<strong>Логическое программирование</strong> лучше всего подходит для анализа и преобразования сложных символических структур в соответствии с наборами логических правил.  <br />
<strong>Дискретное синхронное программирование</strong> лучше всего подходит для “реактивных” задач, когда в системе постоянно происходят реакции на последовательности внешних событий, которые (реакции) после некоторых вычислений генерируют выходные события.  <br />
Популярное сегодня <strong>функционального реактивного программирования</strong> отличается от <strong>FRP</strong> тем, что тут “время” в системе прерывно (шаг времени – это, как правило, произвольный период между двумя входными событиями), в отличие от <strong>FRP</strong>, где время непрерывно. По этой причине <strong>FRP</strong> также называют <strong>непрерывным синхронным программированием</strong>.</p>

<p>Большие и сложные системы, подсистемы которых практически всегда реализуются в разных парадигмах (например, классическая система, состоящая из базы данных, бизнес-логики, сетевого движка и клиентской части), могут быть представлены в виде таких слоёв, как, например, реляционно-логическое программирование, последовательное и параллельное ООП, функциональное реактивное программирование. Уже исходя из такой архитектуры, можно сознательно подбирать наиболее подходящие фреймворки, отбирая их по формальным критериям совместимости фундаментальных концепций, и получить существенный выигрыш в сравнении с несознательным механическим выбором популярного стека.</p>

<p><img src="/image/post-2021-01-10/pic1.jpg" alt="" /></p>

<p>Многие языки программирования поддерживают несколько парадигм, которые можно разделить на две группы:</p>

<ul>
  <li>Парадигмы, поддерживающие <strong>programming in small</strong>. Непосредственное кодирование для класса задач, наиболее часто решаемых данным языком.</li>
  <li>Парадигмы, поддерживающие <strong>programming in large</strong>. Проектирование и создание больших программных систем с поддержкой абстракции и модульности.</li>
</ul>

<p>Таким образом, мы видим, что при правильном проектировании сложных программных систем и проектов, конкретные задачи лучше всего выделять более выразительно, чтобы можно было подобрать более продуктивные языки и фреймворки, точно отвечающие наиболее подходящей парадигме для решения выделенного класса задач. И в результате, получить выигрыш в трудоёмкости в сотни, а то и тысячи раз. Но для этого надо научиться правильно смотреть на слои архитектуры по-научному - глобально, через спектр всех доступных парадигм программирования.</p>


</article>


<a href="/history_posts"><font style="color: gray; font-size: 22px; font-family: Arial">Назад к списку постов</font></a>
<p></p>
<p></p>
<p></p>

      </main>
	  
	
  

      <footer class="footer">
        <small><font style="color: gray; font-size: 16px; font-family: Arial">
		  <p><a href = 'https://vk.com/amelnikofcode'><font style="color: gray; font-size: 16px; font-family: Arial"> Мой профиль в ВК </font></a></p>
		  <p><a href = 'https://github.com/optima740'><font style="color: gray; font-size: 16px; font-family: Arial"> Мой профиль на GitHub</font></a></p>
		  &copy; <time datetime="2021-06-01T17:27:54+04:00">2021</time>
		</font>  
		  
        </small>
      </footer>
    </div>

    
  </body>
</html>
