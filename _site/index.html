<!doctype html>
<html lang="en">
 
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
 
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
  <title>
    
      AndreyMelnikov.MyBlog &middot;    # мой блог: IT-марафон.
    
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-precomposed.ico" type="image/vnd.microsoft.icon">
  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico?">
  <link rel="alternate" type="application/atom+xml" title="AndreyMelnikov.MyBlog" href="/atom.xml">


  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Home" />
<meta name="author" content="Andrey Melnikov" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="AndreyMelnikov.MyBlog" />
<link rel="next" href="http://localhost:4000/page2" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Andrey Melnikov"},"headline":"Home","@type":"WebSite","name":"AndreyMelnikov.MyBlog","url":"http://localhost:4000/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body>

  
	<table>
	<p></p>
	</table>
    <div class="container content">
	
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">AndreyMelnikov.MyBlog</a>
          <small>   # мой блог: IT-марафон.</small>
        </h3>
		<p><img src="/image/my_avatar.jpeg"</p>
      </header>

      <main>
        <a class="btn btn-outline-secondary" href="/history_posts" role="button">
    <font style="color: black; font-size: 24px; font-family: Arial">Все мои посты</font>
</a>


<div class="posts">
  
  <article class="post">
    <h1 class="post-title">
      <a href="/imperative/2021/06/21/Types-in-python/">
        Типы данных в Python.
      </a>
    </h1>

    <time datetime="2021-06-21T00:00:00+03:00" class="post-date">21 Jun 2021</time>

    <p><img src="/image/post-2021-06-29/logo1.jpg" alt="" /></p>

<p>Язык программирования Python из года в год набирает все большую популярность. Данный язык используется во множестве различных сфер, например, AI/ML, Big Data, Data Science, Computer Science. Кроме того, питон имеет достаточно невысокий порог входа для новичков и пропагандируется многими IT-лидерами, что также добавляет дров в печь толкающую популярность вверх.</p>

<p>Сегодня я хотел бы сделать небольшой обзор встроенных типов данных, которые используются внутри языка.<br />
Для начала я постараюсь своими словами объяснить, что такое тип данных.</p>

<p><strong>Тип данных</strong> – это множество допустимых (возможных) значений, для какой-либо программной сущности. Если очень примитивно говорить (для более простого понимания), тип данных необходим для того, чтобы интерпретатор понимал сколько памяти необходимо выделить или зарезервировать под ту или иную сущность, описанную в программе.</p>

<p>Python имеет <strong>динамическую типизацию</strong> (позднее связывание). Данный вид типизации еще принято называть «утиной типизацией», при которой конкретный тип объекта не важен, а важны лишь свойства и методы, которыми этот объект обладает. Другими словами, если объект плавает и крякает как утка, то вероятнее всего, это и есть утка!<br />
При динамической типизации, тип объекта (сущности) определяется не в момент компиляции (трансляции) программы (т.е. до ее запуска), а в момент исполнения программы (т.е. после ее запуска). Типы переменных неизвестны до того момента, пока у них не появляются конкретные значения при запуске программы.</p>

<p>Наряду с динамической типизацией, питон <strong>сильно типизирован</strong>. Это означает, что неявное приведение типов исключено. Например, мы можем определить две переменные без указания типа, но мы не можем сложить эти две переменные, если в одной окажется строка, а в другой число. Компилятор в данном случае вмешается с уточнением.<br />
Кроме того, питон использует ссылочную модель данных, то есть оперирует не значениями, а ссылками (безопасными указателями) на значения (объекты). Я немного писал уже об этом вот в этой своей <a href="https://optima740.github.io/universe/2021/02/02/programming-universe4/">статье</a>.</p>

<p>Также, я хотел бы отметить еще одну характеристику программных сущностей – способность к изменению. Сущность, которая позволяет себя изменить, после того как была определена в программе, называется <strong>мутабельной</strong>. Соответственно, ту сущность которую изменить нельзя, называют <strong>иммутабельной</strong>.<br />
Но, несмотря на «утиную типизацию», встроенные типы данных в питоне все же есть. Ниже я привел типы данных Python, для некоторых из которых будут доступны ссылки на мой GitHub, где я реализовывал их в целях лучшего понимания.</p>

<p><strong>Числовой тип (иммутабельный)</strong>.</p>

<ul>
  <li><strong>int.</strong> – целые числа (числа без дробной части). По сути неограниченной длины. Интерпретатор сам определит необходимость использования объектов неограниченной длины и сделает нужные для этого преобразования.</li>
  <li><strong>float</strong> – числа с плавающей точкой с точностью до 15 десятичных знаков. В памяти представлены как совокупность двух частей: <em>мантиссы</em> и <em>экспоненты</em> (n, e). Мантисса – дробная часть без учета порядка. Экспоненту можно рассматривать как количество цифр перед запятой, отделяющей дробную часть числа. Например: <code class="highlighter-rouge">1.2 E3 = 1.2 * 1000 = 1200</code> (1.2 – мантисса E3 - экспонента)</li>
  <li><strong>complex</strong> – комплексные числа. (состоящие из вещественной и мнимой части как из двух координат). Показательной особенностью комплексных чисел является возможность извлечения корня из отрицательных значений. В Python комплексные числа задаются с помощью функции <code class="highlighter-rouge">complex()</code>:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">z</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mf">2j</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Еще есть «лонги»:</p>

<ul>
  <li><strong>long</strong> – содержит длинные целые числа, которые могут быть представлены в восьмеричной или шестнадцатеричной системе счисления 
(существует в Python 2.x. В Python 3.x данный функционал взяли на себя <code class="highlighter-rouge">int</code>).</li>
</ul>

<p><strong>Логический тип данных (иммутабельный)</strong>.</p>

<ul>
  <li><strong>bool</strong> – True/False (1/0). Тип данных, который принимает 2 значения – истина или ложь. <code class="highlighter-rouge">True</code> и <code class="highlighter-rouge">False</code> в Python являются экземплярами класса <code class="highlighter-rouge">bool</code>, который в свою очередь является подклассом <code class="highlighter-rouge">int</code>. Поэтому <code class="highlighter-rouge">True</code> и <code class="highlighter-rouge">False</code> в Python ведут себя как числа <code class="highlighter-rouge">1</code> и <code class="highlighter-rouge">0</code>. Отличие только в том, как они выводятся на экран.</li>
</ul>

<p><strong>Строки (иммутабельны)</strong>.</p>

<ul>
  <li><strong>str</strong> - cтроки в Python являются экземплярами класса <code class="highlighter-rouge">str</code>. Строка представляет собой последовательность (массив) символов Юникода. Строки неизменяемы.
К элементам строки можно получать доступ по их индексам, как в массиве, а также использовать срезы.</li>
</ul>

<p><strong>Двоичные последовательности</strong>:</p>

<ul>
  <li><strong>bytes (иммутабельны)</strong> – по сути это те же строки, только в двоичном представлении (целое число от 0 до 255), <code class="highlighter-rouge">bytes</code> можно получить из <code class="highlighter-rouge">str</code>, если известна кодировка.</li>
  <li><strong>bytearray (мутабельны)</strong> - массив байт. От типа <code class="highlighter-rouge">bytes</code> отличается только тем, что является изменяемым.</li>
</ul>

<p><strong>Кортежи (иммутабельны)</strong>.</p>

<ul>
  <li><strong>tuple</strong>. Кортеж — это упорядоченная, неизменяемая коллекция объектов произвольных типов. Кортеж является иммутабельным объектом в Python. После определения кортежа, его нельзя изменить. Это дает некотрую выгоду при использовании памяти, т.к. кортеж не может изменяться динамически, в отличие от списков. Однако, не стоит забывать, что в питоне ссылочная модель данных, и если сама структура <code class="highlighter-rouge">tuple</code> не изменяема, то это не значит, что не может изменяться тот объект на который указывает ссылка из кортежа.</li>
</ul>

<p><strong>Cписки (мутабельны)</strong>.<br />
<a href="https://github.com/optima740/Data_structures-Python-/blob/master/level_1/My_new_list.py"><code class="highlighter-rouge">Мой пример реализации на Python</code></a></p>

<ul>
  <li><strong>list</strong>. Cписок можно определить, как упорядоченную и изменяемую коллекцию (набор), состоящую из объектов произвольных типов. По сути, в реализации питона, список – это динамический массив ссылок.</li>
</ul>

<p><strong>Словари (мутабельны)</strong><br />
<a href="https://github.com/optima740/Data_structures-Python-/blob/master/level_1/NativeArray.py"><code class="highlighter-rouge">Мой пример реализации на Python</code></a></p>

<ul>
  <li><strong>dict</strong>. Словарь или ассоциативный массив - представляет собой неупорядоченный набор (не последовательность) пар <code class="highlighter-rouge">«ключ»: «значение»</code>. Если просто описать суть данной структуры данных (не вникая в нюансы коллизий и тд), то она заключается в том, что по значению «ключа» высчитывается хэш, который служит, своего рода индексом для «значения» (структура хэш-таблицы). Т.к. хэши CPU считает очень быстро, то и доступ к элементам словаря практически мгновенный. Кроме того, возможность посчитать хэш есть только для иммутабельных объктов. Потому, ключами для словаря могут стать только неизменяемые объекты, и ключи всегда уникальны.</li>
</ul>

<p><strong>Множества</strong>.<br />
<a href="https://github.com/optima740/Data_structures-Python-/blob/master/level_1/My_Set-new.py"><code class="highlighter-rouge">Мой пример реализации на Python</code></a></p>

<ul>
  <li>
    <p><strong>set (мутабельны)</strong>. Набор (не последовательность) уникальных элементов. Элементами множества могут быть любые неизменяемые объекты. Поскольку множество основано на хэш-таблице, элементы множества должны быть хешируемыми, то есть функция hash() должна работать с ними, а это возможно только с иммутабельными объектами. Для множества доступны основные аналогичные математические операции: объединение, пересечение, разность, симметрическая разность. Одной из часто используемых “полезностей” множества является то, что можно быстро и эффективно определить входит ли элемент(или несколько элементов) в состав набора.</p>
  </li>
  <li>
    <p><strong>frozenset (иммутабельны)</strong>. Отличаются от обычного <code class="highlighter-rouge">set</code> лишь тем, что является неизменяемым типом данных.</p>
  </li>
</ul>

<p>Это был мой краткий обзор основных “коробочных” типов данных в Python. Для ясности и простоты восприятия я решил привести следующую таблицу:</p>

<p><img src="/image/post-2021-06-29/python_type_table.jpg" alt="" /></p>

<p>Ну и еще можно конечно сюда отнести Классы (<strong>class</strong>). Ведь класс - это, по сути, возможность создавать пользовательский тип данных, и в питоне класс также является объектом, порожденным от мета-класса, но об этом в отдельной статье :)</p>


  </article>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page2">Предыдущий</a>
  
  
    <span class="pagination-item newer">Пока это все</span>
  
</div>






      </main>
	  
	
  

      <footer class="footer">
        <small><font style="color: gray; font-size: 16px; font-family: Arial">
		  <p><a href = 'https://vk.com/amelnikofcode'><font style="color: gray; font-size: 16px; font-family: Arial"> Мой профиль в ВК </font></a></p>
		  <p><a href = 'https://github.com/optima740'><font style="color: gray; font-size: 16px; font-family: Arial"> Мой профиль на GitHub</font></a></p>
		  &copy; <time datetime="2021-06-29T11:24:14+03:00">2021</time>
		</font>  
		  
        </small>
      </footer>
    </div>

    
  </body>
</html>
